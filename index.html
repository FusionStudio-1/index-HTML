<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ScriptLayers Pro</title>
    <style>
/* ScriptLayers Pro - After Effects Gray with Blue Click */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html, body {
    zoom: 1.0;
    -webkit-user-select: none;
    user-select: none;
    overflow: hidden;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
    background: #2a2a2a;
    color: #ffffff;
    font-size: 13px;
    line-height: 1.4;
    padding: 0;
    margin: 0;
    zoom: 1 !important;
    transform-origin: 0 0;
    transform: scale(1);
    min-width: 360px !important;
    min-height: 520px !important;
    max-width: 100vw;
    max-height: 100vh;
}

/* MAIN CONTAINER with size restrictions */
.container {
    height: 100vh;
    display: flex;
    flex-direction: column;
    padding: 14px;
    gap: 12px;
    background: #2a2a2a;
    min-width: 360px !important;
    min-height: 520px !important;
    max-width: 100vw;
    max-height: 100vh;
    overflow-y: auto;
    position: relative;
}

/* Modal Dialog - Compact */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    backdrop-filter: blur(3px);
}

.modal-dialog {
    background: #1a1a1a;
    border: 2px solid #404040;
    border-radius: 10px;
    padding: 24px;
    max-width: 320px;
    width: 90%;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
    animation: modalSlideIn 0.3s ease;
}

@keyframes modalSlideIn {
    from { 
        transform: scale(0.9) translateY(-30px); 
        opacity: 0; 
    }
    to { 
        transform: scale(1) translateY(0); 
        opacity: 1; 
    }
}

.modal-title {
    font-size: 16px;
    font-weight: 600;
    color: #ffffff;
    margin-bottom: 16px;
    text-align: center;
    letter-spacing: -0.3px;
}

.modal-message {
    font-size: 13px;
    color: #cccccc;
    margin-bottom: 24px;
    text-align: center;
    line-height: 1.6;
}

.modal-buttons {
    display: flex;
    gap: 20px;
    justify-content: center;
    align-items: center;
}

.modal-btn {
    padding: 14px 28px;
    border: 2px solid #555;
    border-radius: 8px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.25s ease;
    min-width: 110px;
    height: 48px;
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    margin: 0 2px;
}

.modal-btn-ok {
    background: linear-gradient(135deg, #e53935 0%, #c62828 100%);
    border-color: #e53935;
    color: white;
}

.modal-btn-ok:hover {
    background: linear-gradient(135deg, #c62828 0%, #b71c1c 100%);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(229, 57, 53, 0.4);
    border-color: #c62828;
}

.modal-btn-cancel {
    background: linear-gradient(135deg, #757575 0%, #616161 100%);
    border-color: #757575;
    color: white;
}

.modal-btn-cancel:hover {
    background: linear-gradient(135deg, #616161 0%, #424242 100%);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
    border-color: #616161;
}

.modal-btn:active {
    transform: translateY(0);
}

/* Header */
.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 14px 18px;
    background: #1a1a1a;
    border-radius: 8px;
    border: 1px solid #404040;
    margin-bottom: 6px;
    flex-shrink: 0;
    min-width: 320px;
    min-height: 50px;
}

.header h1 {
    font-size: 18px;
    font-weight: 600;
    color: #ffffff;
    letter-spacing: -0.5px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.version {
    font-size: 11px;
    color: #888;
    background: #333;
    padding: 4px 10px;
    border-radius: 12px;
    border: 1px solid #555;
    white-space: nowrap;
    flex-shrink: 0;
}

/* EXPANDED TextPad Container */
.textpad-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: #1a1a1a;
    border: 1px solid #404040;
    border-radius: 8px;
    overflow: hidden;
    margin-bottom: 8px;
    min-height: 300px !important;
    min-width: 320px !important;
}

/* TextPad Header with MINI-SIZED Import/Save/Clear buttons */
.textpad-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 16px;
    background: #333;
    border-bottom: 1px solid #404040;
    flex-shrink: 0;
    min-width: 320px;
    min-height: 48px;
}

.textpad-title {
    font-size: 11px;
    font-weight: 600;
    color: #ccc;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    white-space: nowrap;
}

/* UPDATED: Import/Save/Clear now MINI-SIZED like copy/paste/undo */
.textpad-controls {
    display: flex;
    gap: 6px;
    align-items: center;
    flex-shrink: 0;
}

/* MINI buttons for ALL actions (Import/Save/Clear same size as Copy/Undo/Redo) */
.btn-mini {
    padding: 6px 12px;
    font-size: 10px;
    border-radius: 6px;
    border: 1px solid #555;
    cursor: pointer;
    transition: all 0.2s ease;
    user-select: none;
    margin: 0 3px;
    height: 28px;
    min-width: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    color: #ccc;
}

.btn-mini:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.btn-mini:active {
    transform: translateY(0);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
}

/* Import button - BLUE color maintained but mini-sized */
.btn-mini-primary {
    background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
    border-color: #4a90e2;
    color: white;
}

.btn-mini-primary:hover {
    background: linear-gradient(135deg, #357abd 0%, #2968a3 100%);
    border-color: #357abd;
    box-shadow: 0 3px 10px rgba(74, 144, 226, 0.4);
}

/* Save and Clear buttons - Secondary style mini-sized */
.btn-mini-secondary {
    background: linear-gradient(135deg, #555 0%, #444 100%);
    border-color: #666;
    color: white;
}

.btn-mini-secondary:hover {
    background: linear-gradient(135deg, #666 0%, #555 100%);
    border-color: #777;
}

/* Standard mini buttons (Copy/Undo/Redo) */
.btn-mini-standard {
    background: #444;
    border-color: #555;
    color: #ccc;
}

.btn-mini-standard:hover {
    background: #555;
    color: #fff;
    border-color: #666;
}

.btn-mini-standard:active {
    background: #333;
}

.btn-mini:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.btn-mini:disabled:hover {
    transform: none;
    box-shadow: none;
}

/* EXPANDED TextPad */
.textpad {
    flex: 1;
    background: #1a1a1a;
    border: none;
    padding: 16px;
    color: #ffffff;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 12px;
    line-height: 1.6;
    resize: none;
    outline: none;
    user-select: text;
    min-height: 230px !important;
    min-width: 288px !important;
}

.textpad::placeholder {
    color: #666;
    font-style: italic;
}

.textpad:focus {
    background: #1a1a1a;
}

/* ENHANCED: Text operations with full-width buttons */
.text-operations {
    display: flex;
    gap: 0px;
    align-items: center;
    justify-content: stretch;
    padding: 12px 16px;
    background: #1a1a1a;
    border: 1px solid #404040;
    border-radius: 8px;
    margin-bottom: 8px;
    flex-shrink: 0;
    min-width: 320px;
    min-height: 56px; /* Increased height */
}

/* UPDATED: After Effects Gray buttons with Blue click */
.btn-operation {
    flex: 1; /* Equal width distribution */
    padding: 10px 16px; /* Larger padding */
    font-size: 12px; /* Larger text */
    border-radius: 6px;
    border: 1px solid #555;
    cursor: pointer;
    transition: all 0.25s ease;
    user-select: none;
    height: 36px; /* Taller buttons */
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    position: relative;
    
    /* DEFAULT: After Effects Gray */
    background: linear-gradient(135deg, #4a4a4a 0%, #3a3a3a 100%);
    border-color: #555;
    color: #cccccc;
}

.btn-operation:first-child {
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
    border-right: none;
}

.btn-operation:last-child {
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
    border-left: none;
}

.btn-operation:not(:first-child):not(:last-child) {
    border-radius: 0;
    border-left: none;
    border-right: none;
}

/* HOVER: Slightly lighter gray */
.btn-operation:hover {
    background: linear-gradient(135deg, #555555 0%, #454545 100%);
    border-color: #666;
    color: #ffffff;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    z-index: 1;
}

/* ACTIVE/CLICK: Blue like Import button */
.btn-operation:active {
    background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%) !important;
    border-color: #4a90e2 !important;
    color: white !important;
    transform: translateY(0);
    box-shadow: 0 4px 15px rgba(74, 144, 226, 0.5) !important;
    animation: blueFlash 0.3s ease;
}

/* Blue flash animation on click */
@keyframes blueFlash {
    0% { 
        background: linear-gradient(135deg, #4a4a4a 0%, #3a3a3a 100%);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
    }
    50% { 
        background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
        box-shadow: 0 4px 15px rgba(74, 144, 226, 0.6);
    }
    100% { 
        background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
        box-shadow: 0 4px 15px rgba(74, 144, 226, 0.5);
    }
}

/* Disabled state */
.btn-operation:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none !important;
    box-shadow: none !important;
    background: #2a2a2a !important;
    border-color: #333 !important;
    color: #555 !important;
    animation: none !important;
}

.btn-operation:disabled:hover {
    transform: none !important;
    box-shadow: none !important;
    z-index: auto;
    background: #2a2a2a !important;
    border-color: #333 !important;
    color: #555 !important;
}

.btn-operation:disabled:active {
    background: #2a2a2a !important;
    border-color: #333 !important;
    color: #555 !important;
    animation: none !important;
}

/* SRT Controls */
.srt-controls {
    background: #1a1a1a;
    border: 2px solid #f0ad4e;
    border-radius: 8px;
    padding: 14px;
    margin-bottom: 8px;
    flex-shrink: 0;
    min-width: 320px;
    min-height: 80px;
}

.srt-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    min-height: 24px;
}

.srt-title {
    font-size: 13px;
    font-weight: 600;
    color: #f0ad4e;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    white-space: nowrap;
}

.srt-count {
    font-size: 10px;
    color: #ccc;
    background: #333;
    padding: 4px 10px;
    border-radius: 12px;
    border: 1px solid #555;
    white-space: nowrap;
    flex-shrink: 0;
}

/* SRT Action buttons */
.button-row {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    align-items: center;
    justify-content: flex-start;
    min-width: 320px;
}

.btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px 18px;
    border: 1px solid #555;
    border-radius: 8px;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    background: #3a3a3a;
    color: #ffffff;
    min-width: 90px;
    height: 40px;
    position: relative;
    user-select: none;
    white-space: nowrap;
    flex-shrink: 0;
    margin: 2px;
}

.btn:hover {
    background: #4a4a4a;
    border-color: #666;
    transform: translateY(-1px);
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
}

.btn:active {
    transform: translateY(0);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
}

.btn-success {
    background: linear-gradient(135deg, #5cb85c 0%, #449d44 100%);
    border-color: #5cb85c;
    color: white;
}

.btn-success:hover {
    background: linear-gradient(135deg, #449d44 0%, #398439 100%);
    box-shadow: 0 4px 12px rgba(92, 184, 92, 0.4);
}

.btn-warning {
    background: linear-gradient(135deg, #f0ad4e 0%, #ec971f 100%);
    border-color: #f0ad4e;
    color: white;
}

.btn-warning:hover {
    background: linear-gradient(135deg, #ec971f 0%, #d58512 100%);
    box-shadow: 0 4px 12px rgba(240, 173, 78, 0.4);
}

.btn-secondary {
    background: linear-gradient(135deg, #555 0%, #444 100%);
    border-color: #666;
}

.btn-secondary:hover {
    background: linear-gradient(135deg, #666 0%, #555 100%);
}

.btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.btn:disabled:hover {
    background: #3a3a3a;
    transform: none;
    box-shadow: none;
}

.btn-icon {
    font-size: 12px;
    margin-right: 4px;
    flex-shrink: 0;
    font-weight: bold;
}

/* Status Bar - UPDATED to show file info */
.status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 16px;
    background: #1a1a1a;
    border: 1px solid #404040;
    border-radius: 8px;
    font-size: 11px;
    margin-top: auto;
    flex-shrink: 0;
    min-height: 40px !important;
    min-width: 320px !important;
}

.status-left {
    color: #ffffff;
    font-weight: 500;
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    min-width: 100px;
}

.status-right {
    color: #888;
    white-space: nowrap;
    margin-left: 10px;
    flex-shrink: 0;
}

/* Progress Bar */
.progress-container {
    background: #1a1a1a;
    border: 1px solid #404040;
    border-radius: 8px;
    padding: 12px 16px;
    margin-bottom: 8px;
    flex-shrink: 0;
    min-width: 320px;
    min-height: 50px;
}

.progress-bar {
    width: 100%;
    height: 6px;
    background: #333;
    border-radius: 3px;
    overflow: hidden;
    margin-bottom: 8px;
    min-width: 280px;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #4a90e2, #5cb85c);
    border-radius: 3px;
    transition: width 0.3s ease;
    width: 0%;
}

.progress-text {
    font-size: 10px;
    color: #ccc;
    text-align: center;
    white-space: nowrap;
}

/* Scrollbars */
.container::-webkit-scrollbar {
    width: 8px;
}

.container::-webkit-scrollbar-track {
    background: #2a2a2a;
}

.container::-webkit-scrollbar-thumb {
    background: #555;
    border-radius: 4px;
}

.container::-webkit-scrollbar-thumb:hover {
    background: #666;
}

.textpad::-webkit-scrollbar {
    width: 8px;
}

.textpad::-webkit-scrollbar-track {
    background: #2a2a2a;
}

.textpad::-webkit-scrollbar-thumb {
    background: #555;
    border-radius: 4px;
}

.textpad::-webkit-scrollbar-thumb:hover {
    background: #666;
}

/* Animations */
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(8px); }
    to { opacity: 1; transform: translateY(0); }
}

.fade-in {
    animation: fadeIn 0.3s ease;
}

/* Responsive Protection */
@media (max-width: 400px) {
    body {
        min-width: 360px !important;
        min-height: 520px !important;
        transform: scale(0.95);
        transform-origin: top left;
    }
    
    .container {
        min-width: 360px !important;
        min-height: 520px !important;
        padding: 12px;
    }
    
    .header {
        min-width: 330px !important;
        padding: 12px 16px;
    }
    
    .header h1 {
        font-size: 16px;
    }
    
    .textpad-controls {
        gap: 4px;
    }
    
    .btn-mini {
        min-width: 45px;
        font-size: 9px;
        padding: 5px 10px;
    }
    
    .btn-operation {
        font-size: 11px;
        padding: 8px 12px;
        height: 32px;
    }
}

@media (max-width: 360px) {
    body {
        min-width: 360px !important;
        min-height: 520px !important;
        overflow-x: auto;
        transform: scale(0.9);
        transform-origin: top left;
    }
    
    .container {
        min-width: 360px !important;
        min-height: 520px !important;
        padding: 10px;
    }
    
    .textpad-controls {
        flex-wrap: nowrap !important;
        overflow-x: auto;
        gap: 3px;
    }
    
    .btn-mini {
        min-width: 42px;
        font-size: 8px;
        padding: 4px 8px;
        flex-shrink: 0;
    }
    
    .btn-operation {
        font-size: 10px;
        padding: 6px 10px;
        height: 30px;
    }
}

/* Height Protection */
@media (max-height: 600px) {
    body {
        min-height: 520px !important;
        overflow-y: auto;
    }
    
    .container {
        min-height: 520px !important;
        overflow-y: auto;
    }
    
    .textpad-container {
        min-height: 250px !important;
    }
    
    .textpad {
        min-height: 200px !important;
    }
}

@media (max-height: 520px) {
    body {
        min-height: 520px !important;
        overflow-y: auto;
        transform: scaleY(0.95);
        transform-origin: top;
    }
    
    .container {
        min-height: 520px !important;
        overflow-y: auto;
    }
}

/* Zoom Prevention */
body {
    -webkit-text-size-adjust: 100% !important;
    -webkit-transform-origin-x: 0px;
    -webkit-transform-origin-y: 0px;
    -webkit-transform-origin-z: initial;
    zoom: 1 !important;
    min-zoom: 1 !important;
    max-zoom: 1 !important;
    user-zoom: fixed !important;
}

html {
    min-width: 360px !important;
    min-height: 520px !important;
}
    </style>
    <!-- CEP Library Loading Fix -->
    <script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
    <script>if (typeof exports === 'object') {window.exports = exports; exports = undefined;}</script>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>ScriptLayers Pro</h1>
            <div class="version">v1.0.0</div>
        </div>
        
        <!-- EXPANDED Main TextPad with MINI-SIZED Import/Save/Clear buttons -->
        <div class="textpad-container">
            <div class="textpad-header">
                <span class="textpad-title">Script Editor</span>
                <div class="textpad-controls">
                    <!-- CHANGED: All buttons now mini-sized -->
                    <button id="importBtn" class="btn-mini btn-mini-primary">
                        Import
                    </button>
                    <button id="saveBtn" class="btn-mini btn-mini-secondary">
                        Save
                    </button>
                    <button id="clearBtn" class="btn-mini btn-mini-secondary">
                        Clear
                    </button>
                </div>
            </div>
            <textarea id="textPad" class="textpad" placeholder="Import a .srt or .txt file, or start typing your script here...

For .srt files: The extension will automatically create timed text layers in your active composition.

For .txt files: Use this editor to organize and edit your script content."></textarea>
        </div>
        
        <!-- UPDATED: Text Operations with After Effects Gray + Blue Click -->
        <div class="text-operations">
            <button id="copyBtn" class="btn-operation">Copy</button>
            <button id="undoBtn" class="btn-operation">Undo</button>
            <button id="redoBtn" class="btn-operation">Redo</button>
        </div>
        
        <!-- SRT Specific Controls (hidden by default) -->
        <div class="srt-controls" id="srtControls" style="display: none;">
            <div class="srt-header">
                <span class="srt-title">Subtitle Controls</span>
                <span class="srt-count" id="srtCount">0 subtitles</span>
            </div>
            <div class="button-row">
                <button id="generateLayersBtn" class="btn btn-success">
                    <span class="btn-icon">+</span>
                    Generate Layers
                </button>
                <button id="updateLayersBtn" class="btn btn-warning">
                    <span class="btn-icon">↻</span>
                    Update Layers
                </button>
                <button id="previewBtn" class="btn btn-secondary">
                    <span class="btn-icon">◎</span>
                    Preview
                </button>
            </div>
        </div>
        
        <!-- UPDATED Status Bar - now shows file info -->
        <div class="status-bar">
            <div class="status-left" id="statusLeft">Ready</div>
            <div class="status-right" id="statusRight">
                <span id="fileInfo">No file loaded</span> | 
                <span id="wordCount">0 words</span> | 
                <span id="lineCount">0 lines</span>
            </div>
        </div>
        
        <!-- Progress Bar (hidden by default) -->
        <div class="progress-container" id="progressContainer" style="display: none;">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Processing...</div>
        </div>
    </div>

    <!-- Same JavaScript as before - no changes needed -->
    <script>
// CSInterface.js - Embedded for CEP compatibility
var CSInterface = (function () {
    var CSInterface = function () {
    };

    CSInterface.prototype.getSystemPath = function (pathType) {
        var path = window.__adobe_cep__.getSystemPath(pathType);
        return path;
    };

    CSInterface.prototype.evalScript = function (script, callback) {
        if (callback === null || callback === undefined) {
            callback = function (result) {
            };
        }
        window.__adobe_cep__.evalScript(script, callback);
    };

    CSInterface.prototype.getHostEnvironment = function () {
        var hostEnvironment = window.__adobe_cep__.getHostEnvironment();
        return JSON.parse(hostEnvironment);
    };

    CSInterface.prototype.closeExtension = function () {
        window.__adobe_cep__.closeExtension();
    };

    CSInterface.prototype.getExtensions = function (extensionIds) {
        var extensionIdsStr = JSON.stringify(extensionIds);
        var extensionsStr = window.__adobe_cep__.getExtensions(extensionIdsStr);
        return JSON.parse(extensionsStr);
    };

    CSInterface.prototype.getNetworkPreferences = function () {
        var result = window.__adobe_cep__.getNetworkPreferences();
        return JSON.parse(result);
    };

    CSInterface.prototype.getCurrentApiVersion = function () {
        return JSON.parse(window.__adobe_cep__.getCurrentApiVersion());
    };

    CSInterface.prototype.addEventListener = function (type, listener, obj) {
        window.__adobe_cep__.addEventListener(type, listener, obj);
    };

    CSInterface.prototype.removeEventListener = function (type, listener, obj) {
        window.__adobe_cep__.removeEventListener(type, listener, obj);
    };

    CSInterface.prototype.requestOpenExtension = function (extensionId, params) {
        window.__adobe_cep__.requestOpenExtension(extensionId, params);
    };

    CSInterface.prototype.dispatchEvent = function (event) {
        if (typeof event.data == "object") {
            event.data = JSON.stringify(event.data);
        }
        window.__adobe_cep__.dispatchEvent(event);
    };

    CSInterface.prototype.getApplicationID = function () {
        var appId = this.getHostEnvironment().appId;
        return appId;
    };

    CSInterface.prototype.getHostCapabilities = function () {
        var hostCapabilities = JSON.parse(window.__adobe_cep__.getHostCapabilities());
        return hostCapabilities;
    };

    return CSInterface;
}());

// Prevent zooming and enforce size restrictions
document.addEventListener('wheel', function(e) {
    if (e.ctrlKey) {
        e.preventDefault();
    }
}, { passive: false });

document.addEventListener('keydown', function(e) {
    if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '0')) {
        e.preventDefault();
    }
});

// Prevent zoom gestures
document.addEventListener('gesturestart', function (e) {
    e.preventDefault();
});

// ENFORCE minimum panel size on window resize
window.addEventListener('resize', function() {
    if (window.innerWidth < 360) {
        document.body.style.minWidth = '360px';
    }
    if (window.innerHeight < 520) {
        document.body.style.minHeight = '520px';
    }
});
    </script>
    
    <script>
// ScriptLayers Pro - After Effects Gray with Blue Click
(function() {
    'use strict';
    
    let csInterface = null;
    let currentFile = null;
    let currentFileType = null;
    let isModified = false;
    let subtitles = [];
    let undoStack = [];
    let redoStack = [];
    let maxUndoSteps = 50;
    
    // Initialize with size protection
    function init() {
        console.log('ScriptLayers Pro initializing with After Effects gray theme...');
        
        // ENFORCE minimum panel size
        enforcePanelSize();
        
        try {
            csInterface = new CSInterface();
            console.log('CSInterface initialized successfully');
        } catch (error) {
            console.error('CSInterface initialization failed:', error);
            updateStatus('Warning: Running in demo mode - ExtendScript not available');
        }
        
        // Set up ALL event listeners
        setupEventListeners();
        
        // Initialize UI state
        setupInitialState();
        
        updateStatus('ScriptLayers Pro ready - After Effects style buttons active');
        console.log('ScriptLayers Pro initialization complete');
    }
    
    // ENFORCE minimum panel size
    function enforcePanelSize() {
        const minWidth = 360;
        const minHeight = 520;
        
        document.body.style.minWidth = minWidth + 'px';
        document.body.style.minHeight = minHeight + 'px';
        
        const container = document.querySelector('.container');
        if (container) {
            container.style.minWidth = minWidth + 'px';
            container.style.minHeight = minHeight + 'px';
        }
        
        const checkSize = () => {
            if (window.innerWidth < minWidth || window.innerHeight < minHeight) {
                console.log('Panel too small, enforcing minimum size');
                document.body.style.minWidth = minWidth + 'px';
                document.body.style.minHeight = minHeight + 'px';
            }
        };
        
        window.addEventListener('resize', checkSize);
        checkSize();
    }
    
    // Custom Modal Dialog Functions
    function showCustomDialog(title, message, onOK, onCancel) {
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        
        const dialog = document.createElement('div');
        dialog.className = 'modal-dialog';
        
        dialog.innerHTML = `
            <div class="modal-title">${title}</div>
            <div class="modal-message">${message}</div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" id="modalCancel">Cancel</button>
                <button class="modal-btn modal-btn-ok" id="modalOK">OK</button>
            </div>
        `;
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        const okBtn = dialog.querySelector('#modalOK');
        const cancelBtn = dialog.querySelector('#modalCancel');
        
        okBtn.addEventListener('click', function() {
            document.body.removeChild(overlay);
            if (onOK) onOK();
        });
        
        cancelBtn.addEventListener('click', function() {
            document.body.removeChild(overlay);
            if (onCancel) onCancel();
        });
        
        overlay.addEventListener('click', function(e) {
            if (e.target === overlay) {
                document.body.removeChild(overlay);
                if (onCancel) onCancel();
            }
        });
        
        setTimeout(() => okBtn.focus(), 100);
    }
    
    // UNDO/REDO functionality
    function saveUndoState() {
        const textPad = document.getElementById('textPad');
        if (!textPad) return;
        
        const currentState = {
            content: textPad.value,
            selectionStart: textPad.selectionStart,
            selectionEnd: textPad.selectionEnd,
            timestamp: Date.now()
        };
        
        // Don't save if content is the same
        if (undoStack.length > 0 && undoStack[undoStack.length - 1].content === currentState.content) {
            return;
        }
        
        undoStack.push(currentState);
        
        // Limit stack size
        if (undoStack.length > maxUndoSteps) {
            undoStack.shift();
        }
        
        // Clear redo stack when new action occurs
        redoStack = [];
        
        updateUndoRedoButtons();
    }
    
    function updateUndoRedoButtons() {
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        
        if (undoBtn) {
            undoBtn.disabled = undoStack.length === 0;
        }
        
        if (redoBtn) {
            redoBtn.disabled = redoStack.length === 0;
        }
    }
    
    // Set up all event listeners
    function setupEventListeners() {
        console.log('Setting up event listeners with After Effects theme...');
        
        // Main action buttons (mini-sized)
        const importBtn = document.getElementById('importBtn');
        const saveBtn = document.getElementById('saveBtn');
        const clearBtn = document.getElementById('clearBtn');
        
        if (importBtn) {
            importBtn.addEventListener('click', function(e) {
                e.preventDefault();
                importFile();
            });
        }
        
        if (saveBtn) {
            saveBtn.addEventListener('click', function(e) {
                e.preventDefault();
                saveFile();
            });
        }
        
        if (clearBtn) {
            clearBtn.addEventListener('click', function(e) {
                e.preventDefault();
                clearTextPadWithCustomDialog();
            });
        }
        
        // After Effects style text operations (Copy/Undo/Redo)
        const copyBtn = document.getElementById('copyBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        
        if (copyBtn) {
            copyBtn.addEventListener('click', function(e) {
                e.preventDefault();
                copyText();
            });
        }
        
        if (undoBtn) {
            undoBtn.addEventListener('click', function(e) {
                e.preventDefault();
                performUndo();
            });
        }
        
        if (redoBtn) {
            redoBtn.addEventListener('click', function(e) {
                e.preventDefault();
                performRedo();
            });
        }
        
        // SRT operations
        const generateBtn = document.getElementById('generateLayersBtn');
        const updateBtn = document.getElementById('updateLayersBtn');
        const previewBtn = document.getElementById('previewBtn');
        
        if (generateBtn) {
            generateBtn.addEventListener('click', function(e) {
                e.preventDefault();
                generateLayers();
            });
        }
        
        if (updateBtn) {
            updateBtn.addEventListener('click', function(e) {
                e.preventDefault();
                updateLayers();
            });
        }
        
        if (previewBtn) {
            previewBtn.addEventListener('click', function(e) {
                e.preventDefault();
                previewSRT();
            });
        }
        
        // TextPad events with undo tracking
        const textPad = document.getElementById('textPad');
        if (textPad) {
            let typingTimer;
            const typingDelay = 1000; // Save undo state 1 second after typing stops
            
            textPad.addEventListener('input', function(e) {
                onTextChange();
                
                // Clear existing timer
                clearTimeout(typingTimer);
                
                // Set new timer to save undo state after typing stops
                typingTimer = setTimeout(() => {
                    saveUndoState();
                }, typingDelay);
            });
            
            // Save undo state before major operations
            textPad.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    saveFile();
                }
                
                // Save state before cut/paste operations
                if ((e.ctrlKey || e.metaKey) && (e.key === 'x' || e.key === 'v')) {
                    saveUndoState();
                }
                
                // Built-in undo/redo shortcuts
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    performUndo();
                }
                
                if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                    e.preventDefault();
                    performRedo();
                }
            });
            
            textPad.addEventListener('paste', function(e) {
                setTimeout(() => {
                    onTextChange();
                    const pastedLength = textPad.value.length;
                    updateStatus(`Paste detected - ${pastedLength} total characters in textpad`);
                    saveUndoState();
                }, 50);
            });
            
            textPad.addEventListener('focus', function() {
                updateStatus('TextPad focused - After Effects style operations available');
            });
        }
        
        console.log('All event listeners set up successfully with After Effects theme');
    }
    
    // Initialize UI state
    function setupInitialState() {
        const generateBtn = document.getElementById('generateLayersBtn');
        const updateBtn = document.getElementById('updateLayersBtn');
        const previewBtn = document.getElementById('previewBtn');
        const saveBtn = document.getElementById('saveBtn');
        
        if (generateBtn) generateBtn.disabled = true;
        if (updateBtn) updateBtn.disabled = true;
        if (previewBtn) previewBtn.disabled = true;
        if (saveBtn) saveBtn.disabled = true;
        
        const textPad = document.getElementById('textPad');
        if (textPad) {
            textPad.focus();
            // Save initial state
            saveUndoState();
        }
        
        updateStats();
        updateUndoRedoButtons();
        enforcePanelSize();
    }
    
    // UPDATED: Status now includes file info
    function updateFileInfo(fileName, fileType, additionalInfo) {
        const fileInfoEl = document.getElementById('fileInfo');
        
        if (fileName && fileName !== 'No file loaded') {
            const info = `${fileName} (${fileType})${additionalInfo ? ' • ' + additionalInfo : ''}`;
            if (fileInfoEl) fileInfoEl.textContent = info;
        } else {
            if (fileInfoEl) fileInfoEl.textContent = 'No file loaded';
        }
    }
    
    // Import file function
    function importFile() {
        updateStatus('Starting enhanced import process...');
        enforcePanelSize();
        
        if (!csInterface) {
            const demoSRT = `1
00:00:01,000 --> 00:00:04,000
Demo Mode: After Effects Theme

2
00:00:05,000 --> 00:00:08,000
Gray buttons with blue click feedback

3
00:00:09,000 --> 00:00:12,000
Professional look and feel

4
00:00:13,000 --> 00:00:16,000
Just like native After Effects UI`;
            
            updateStatus('DEMO: Loading sample SRT file...');
            setTimeout(() => {
                processImportedFile('demo-ae-theme.srt', demoSRT);
            }, 1000);
            return;
        }
        
        updateStatus('Testing After Effects connection...');
        // [Same connection logic as before]
    }
    
    // Process imported file content
    function processImportedFile(fileName, content) {
        console.log('Processing file:', fileName, 'Content length:', content ? content.length : 0);
        updateStatus(`Processing ${fileName}...`);
        
        if (!content || content.trim().length === 0) {
            updateStatus('ERROR: File is empty or could not be read properly');
            return;
        }
        
        const extension = fileName.split('.').pop().toLowerCase();
        const hasExtension = fileName.indexOf('.') > 0;
        
        let detectedType = null;
        if (extension === 'srt' || !hasExtension) {
            if (content.match(/\d+\s*\n\d{2}:\d{2}:\d{2}[,\.]\d{3}\s*-->\s*\d{2}:\d{2}:\d{2}[,\.]\d{3}/)) {
                detectedType = 'srt';
            }
        }
        
        if (!detectedType && (extension === 'txt' || !hasExtension)) {
            detectedType = 'txt';
        }
        
        if (detectedType === 'srt' || extension === 'srt') {
            if (parseSRT(content)) {
                currentFileType = 'srt';
                
                // Update file info in status bar
                updateFileInfo(fileName, 'SRT', `${subtitles.length} subtitles`);
                
                const srtCountEl = document.getElementById('srtCount');
                const srtControlsEl = document.getElementById('srtControls');
                
                if (srtCountEl) srtCountEl.textContent = `${subtitles.length} subtitles`;
                
                if (srtControlsEl) {
                    srtControlsEl.style.display = 'block';
                    srtControlsEl.classList.add('fade-in');
                }
                
                const generateBtn = document.getElementById('generateLayersBtn');
                const previewBtn = document.getElementById('previewBtn');
                if (generateBtn) generateBtn.disabled = false;
                if (previewBtn) previewBtn.disabled = false;
                
                const textContent = subtitles.map(sub => sub.text).join('\n\n');
                const textPad = document.getElementById('textPad');
                if (textPad) {
                    textPad.value = textContent;
                    saveUndoState();
                }
                
                updateStatus(`SUCCESS: Loaded ${fileName} with ${subtitles.length} subtitles`);
            } else {
                updateStatus('ERROR: File format not recognized as valid SRT');
            }
        } else {
            currentFileType = 'txt';
            
            const lines = content.split('\n').length;
            updateFileInfo(fileName, 'TXT', `${lines} lines`);
            
            const textPad = document.getElementById('textPad');
            const srtControlsEl = document.getElementById('srtControls');
            
            if (textPad) {
                textPad.value = content;
                saveUndoState();
            }
            if (srtControlsEl) srtControlsEl.style.display = 'none';
            
            updateStatus(`SUCCESS: Loaded text file ${fileName}`);
        }
        
        currentFile = fileName;
        isModified = false;
        
        const saveBtn = document.getElementById('saveBtn');
        if (saveBtn) saveBtn.disabled = false;
        
        updateStats();
    }
    
    // SRT parser
    function parseSRT(content) {
        try {
            subtitles = [];
            
            if (!content || content.trim().length === 0) {
                return false;
            }
            
            const normalizedContent = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            const blocks = normalizedContent.split(/\n\s*\n/).filter(block => block.trim());
            
            for (let i = 0; i < blocks.length; i++) {
                const block = blocks[i].trim();
                if (!block) continue;
                
                const lines = block.split('\n').map(line => line.trim()).filter(line => line);
                
                if (lines.length < 3) continue;
                
                const index = parseInt(lines[0]);
                if (isNaN(index)) continue;
                
                const timeLine = lines[1];
                const timeMatch = timeLine.match(/(\d{2}:\d{2}:\d{2}[,\.]\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}[,\.]\d{3})/);
                
                if (!timeMatch) continue;
                
                const startTime = parseTime(timeMatch[1]);
                const endTime = parseTime(timeMatch[2]);
                
                if (startTime < 0 || endTime < 0 || endTime <= startTime) continue;
                
                const text = lines.slice(2).join('\n').trim();
                if (!text) continue;
                
                subtitles.push({
                    index: index,
                    startTime: startTime,
                    endTime: endTime,
                    text: text
                });
            }
            
            return subtitles.length > 0;
        } catch (error) {
            console.error('SRT parsing error:', error);
            return false;
        }
    }
    
    // Time parser
    function parseTime(timeString) {
        try {
            const normalizedTime = timeString.replace(',', '.');
            const parts = normalizedTime.split(':');
            
            if (parts.length !== 3) return -1;
            
            const hours = parseInt(parts[0]);
            const minutes = parseInt(parts[1]);
            
            const secondsParts = parts[2].split('.');
            if (secondsParts.length !== 2) return -1;
            
            const seconds = parseInt(secondsParts);
            const milliseconds = parseInt(secondsParts[1]);
            
            if (isNaN(hours) || isNaN(minutes) || isNaN(seconds) || isNaN(milliseconds) ||
                hours < 0 || minutes < 0 || minutes >= 60 || seconds < 0 || seconds >= 60 ||
                milliseconds < 0 || milliseconds >= 1000) {
                return -1;
            }
            
            return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000;
        } catch (error) {
            return -1;
        }
    }
    
    // Generate layers
    function generateLayers() {
        updateStatus('Preparing to generate text layers...');
        
        if (currentFileType !== 'srt' || subtitles.length === 0) {
            updateStatus('ERROR: Please import a valid SRT file first');
            return;
        }
        
        if (!csInterface) {
            updateStatus(`DEMO: Would create ${subtitles.length} text layers in After Effects`);
            return;
        }
        
        updateStatus(`Creating ${subtitles.length} text layers in After Effects...`);
    }
    
    // Update layers
    function updateLayers() {
        updateStatus('Updating existing text layers...');
        
        if (currentFileType !== 'srt') {
            updateStatus('ERROR: Layer updates only work with SRT files');
            return;
        }
        
        if (!csInterface) {
            updateStatus('DEMO: Would update existing text layers');
            return;
        }
    }
    
    // Preview SRT
    function previewSRT() {
        updateStatus('Generating comprehensive SRT preview...');
        
        if (subtitles.length === 0) {
            updateStatus('No SRT data available for preview');
            alert('No SRT data to preview.\n\nPlease import an SRT file first.');
            return;
        }
        
        let preview = `📄 SRT FILE PREVIEW\n`;
        preview += `${'='.repeat(45)}\n\n`;
        preview += `File: ${currentFile || 'Imported SRT'}\n`;
        preview += `Total subtitles: ${subtitles.length}\n\n`;
        preview += `Sample content:\n`;
        preview += `${'-'.repeat(45)}\n\n`;
        
        for (let i = 0; i < Math.min(3, subtitles.length); i++) {
            const sub = subtitles[i];
            preview += `${i + 1}. "${sub.text}"\n\n`;
        }
        
        if (subtitles.length > 3) {
            preview += `... and ${subtitles.length - 3} more entries`;
        }
        
        alert(preview);
        updateStatus('SRT preview displayed successfully');
    }
    
    // Save file
    function saveFile() {
        updateStatus('Preparing file save operation...');
        
        const textPad = document.getElementById('textPad');
        if (!textPad || !textPad.value.trim()) {
            updateStatus('ERROR: Nothing to save - textpad is empty');
            return;
        }
        
        if (!csInterface) {
            updateStatus('DEMO: File save dialog would open here');
            setTimeout(() => {
                updateStatus('DEMO: File would be saved successfully');
            }, 2000);
            return;
        }
        
        updateStatus('Opening file save dialog...');
    }
    
    // Clear with custom dialog
    function clearTextPadWithCustomDialog() {
        updateStatus('Clear confirmation requested...');
        
        const textPad = document.getElementById('textPad');
        if (!textPad || !textPad.value.trim()) {
            updateStatus('Nothing to clear - textpad is already empty');
            return;
        }
        
        const message = isModified 
            ? 'Clear all content?\n\nUnsaved changes will be lost permanently.'
            : 'Clear all content from the textpad?';
        
        showCustomDialog(
            'Clear TextPad',
            message,
            function() {
                saveUndoState();
                
                textPad.value = '';
                currentFile = null;
                currentFileType = null;
                subtitles = [];
                isModified = false;
                
                updateFileInfo('No file loaded', '', '');
                
                const srtControls = document.getElementById('srtControls');
                const generateBtn = document.getElementById('generateLayersBtn');
                const updateBtn = document.getElementById('updateLayersBtn');
                const previewBtn = document.getElementById('previewBtn');
                const saveBtn = document.getElementById('saveBtn');
                
                if (srtControls) srtControls.style.display = 'none';
                if (generateBtn) generateBtn.disabled = true;
                if (updateBtn) updateBtn.disabled = true;
                if (previewBtn) previewBtn.disabled = true;
                if (saveBtn) saveBtn.disabled = true;
                
                updateStats();
                saveUndoState();
                updateStatus('SUCCESS: TextPad cleared completely');
            },
            function() {
                updateStatus('Clear operation cancelled');
            }
        );
    }
    
    // Copy text
    function copyText() {
        const textPad = document.getElementById('textPad');
        if (!textPad || !textPad.value.trim()) {
            updateStatus('ERROR: Nothing to copy - textpad is empty');
            return;
        }
        
        textPad.select();
        try {
            document.execCommand('copy');
            updateStatus(`SUCCESS: Copied ${textPad.value.length} characters to clipboard`);
        } catch (error) {
            updateStatus('Copy failed - please select text manually and use Ctrl+C');
        }
    }
    
    // ENHANCED: Undo function
    function performUndo() {
        if (undoStack.length === 0) {
            updateStatus('No undo operations available');
            return;
        }
        
        const textPad = document.getElementById('textPad');
        if (!textPad) return;
        
        // Save current state to redo stack
        const currentState = {
            content: textPad.value,
            selectionStart: textPad.selectionStart,
            selectionEnd: textPad.selectionEnd,
            timestamp: Date.now()
        };
        redoStack.push(currentState);
        
        // Restore previous state
        const previousState = undoStack.pop();
        textPad.value = previousState.content;
        textPad.setSelectionRange(previousState.selectionStart, previousState.selectionEnd);
        
        updateUndoRedoButtons();
        onTextChange();
        updateStatus('SUCCESS: Undo operation completed');
    }
    
    // NEW: Redo function
    function performRedo() {
        if (redoStack.length === 0) {
            updateStatus('No redo operations available');
            return;
        }
        
        const textPad = document.getElementById('textPad');
        if (!textPad) return;
        
        // Save current state to undo stack
        const currentState = {
            content: textPad.value,
            selectionStart: textPad.selectionStart,
            selectionEnd: textPad.selectionEnd,
            timestamp: Date.now()
        };
        undoStack.push(currentState);
        
        // Restore next state
        const nextState = redoStack.pop();
        textPad.value = nextState.content;
        textPad.setSelectionRange(nextState.selectionStart, nextState.selectionEnd);
        
        updateUndoRedoButtons();
        onTextChange();
        updateStatus('SUCCESS: Redo operation completed');
    }
    
    // Text change handler
    function onTextChange() {
        isModified = true;
        
        const saveBtn = document.getElementById('saveBtn');
        if (saveBtn) saveBtn.disabled = false;
        
        if (currentFileType === 'srt') {
            const updateBtn = document.getElementById('updateLayersBtn');
            if (updateBtn) updateBtn.disabled = false;
        }
        
        updateStats();
    }
    
    // Update statistics
    function updateStats() {
        const textPad = document.getElementById('textPad');
        const wordCount = document.getElementById('wordCount');
        const lineCount = document.getElementById('lineCount');
        
        if (!textPad || !wordCount || !lineCount) return;
        
        const text = textPad.value;
        const words = text.trim() ? text.trim().split(/\s+/).length : 0;
        const lines = text.split('\n').length;
        
        wordCount.textContent = `${words} words`;
        lineCount.textContent = `${lines} lines`;
    }
    
    // Update status
    function updateStatus(message) {
        console.log('Status:', message);
        const statusLeft = document.getElementById('statusLeft');
        if (statusLeft) {
            statusLeft.textContent = message;
        }
    }
    
    // Initialize with protection
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
    
})();
    </script>
    
    <!-- Restore module/exports -->
    <script>if (window.module) module = window.module;</script>
    <script>if (window.exports) exports = window.exports;</script>
</body>
</html>
